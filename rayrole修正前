// メール振り分け処理（送信元がno-reply@rayrole.jp）
// Gmail内の受信メールを判別振り分け（ラベル付与）処理を行う
const SortMailRayrole = () => {
  const searchFrom = "from:no-reply@rayrole.jp"; //送信アドレス
  const searchLabel = "label:inbox"; //ラベル条件：受信ボックス
  const searchErrorLabel = "label:エラー";
  const matchNumber = "【会員番号】";
  const titleNew = "【新規予約】";
  const titleMember = "【既存予約】";
  const titleCancel = "【予約キャンセル】";
  const titleChange = "【予約変更】";
  const textNew = "【予約属性】新規";
  const textMember = "【予約属性】既存";
  const textHPB = "【メニュー】HPB";
  const reserve = ['','','','','','','','','','','','']

  const labelExisting = GmailApp.getUserLabelByName("既存");
  const labelNew = GmailApp.getUserLabelByName("新規");
  const labelError = GmailApp.getUserLabelByName("エラー");
  const threads = GmailApp.search(`${searchFrom} ${searchLabel}`);
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const analysisSheet = ss.getSheetByName("新規予約一覧");
  const analysisSheetLastRow = analysisSheet.getDataRange().getLastRow();

  // 各項目の列番号を取得
  const idRow = 4; // IDの記載された行番号
  const dat = analysisSheet.getRange(idRow, 1, 1, 20).getValues().flat(); // IDの並びを20列目まで取得
  reserveNumCol = findCol('$reserveNum$', dat)                   // 予約番号($reserveNum$)を取得
  reserveProceduralDay = findCol('$reserveProceduralDay$', dat)  // 予約手続日時（$reserveProceduralDay$）
  firstReserveDay = findCol('$1stReserveDay$', dat)              // 予約日時($1stReserveDay$)
  firstShopId = findCol('$1stShopId$', dat)                      // 予約店舗（$1stShopId$）
  cusNum = findCol('$cusNum$', dat)                              // 会員番号（$cusNum$）
  cusName = findCol('$cusName$', dat)                            // 名前（$cusName$）
  cusTel = findCol('$cusTel$', dat)                              // 電話番号（$cusTel$）
  cusBirthDay = findCol('$cusBirthDay$', dat)                    // 生年月日（$cusBirthDay$）
  cusAge = findCol('$cusAge$', dat)                              // "来店時 年齢"（$cusAge$）
  visitStatus = findCol('$visitStatus$', dat)                    // 来店ステータス（$visitStatus$）
  firstSt = findCol('$1stSt$', dat)                              // 初回担当者（$1stSt$）
  remark = findCol('$Remark$', dat)                              // 備考（$Remark$）

  // スレッドごとにチェック
  for(let i in threads.reverse()){
    const message = threads[i].getMessages()[0];
    const plainBody = message.getPlainBody();  // メッセージ内容
    const messageTitle = message.getSubject(); // タイトル（件名）

    // /////////////////////////////////////////////////////////////////
    // 1. 初来店処理
    // /////////////////////////////////////////////////////////////////
    if (messageTitle.match(titleNew)                                     // タイトルが【新規予約】
    || (messageTitle.match(titleCancel) && plainBody.match(textNew))    // タイトルが【予約キャンセル】かつ予約属性が新規
    || (messageTitle.match(titleChange) && plainBody.match(textNew))){  // タイトルが【予約変更】     かつ予約属性が新規
      reserve[reserveProceduralDay] = (message.getDate()); // 予約手続き日時を取得
      const listSheet = ss.getSheetByName("プルダウンリスト");
      const listSheetLastRow = listSheet.getDataRange().getLastRow();
      const storeList = listSheet.getRange(3, 2, listSheetLastRow, 1).getValues().flat(); // 店舗リストの配列を生成
      const gmailText = plainBody.split("\n");                                            // 本文を改行で分割して配列を生成

      // メニューの項目にHPBが含まれていない
      if(!plainBody.match(textHPB)) {

          // ////////////////////////////
          // 1-1. 新規予約の場合
          // ////////////////////////////
          if (threads[i].getFirstMessageSubject().match(titleNew)){                           // 件名が【新規予約】の場合
            console.log(threads[i].getFirstMessageSubject());                                    // 件名をログ出力
            const arrReserve = arrGmailText1(gmailText, reserve, matchNumber, storeList);      // メールからデータを取得しIDの順番に配列化

            console.log(arrReserve)

            // 最終行に新規予約挿入
            const newLastRow = analysisSheet.getRange(analysisSheetLastRow, 2).getNextDataCell(SpreadsheetApp.Direction.UP).getRow() + 1;
            analysisSheet.getRange(newLastRow, 1, 1, 12).setValues([arrReserve]);

            // 電話対応履歴に追加
            setTel(reserve[reserveNumCol])

            // エラーチェック処理（シート上に重複の電話番号があるか配列で確認。あればエラー記載）
            const errorRange = analysisSheet.getRange(newLastRow, remark + 1);
            const reserveTEL = analysisSheet.getRange(6, cusTel + 1, newLastRow - 6, 1).getValues().reverse().flat();
            for(let n in reserveTEL){
              if(reserve[cusTel] !== ""){
                if(reserveTEL[n] == reserve[cusTel]){
                  const errorPt2 = "【確認事項】過去の電話番号と重複しています。既存の可能性があるので確認してください。";
                  const errorValue2 = errorRange.getValue();
                  errorRange.setValue(`${errorPt2}${errorValue2}`);
                  break;
                }
              }
            }
          }

          // ////////////////////////////
          // 1-2. 予約内容変更の場合
          // ////////////////////////////
          else if(threads[i].getFirstMessageSubject().match(titleChange)
          && plainBody.match(textNew)){                                                       // 件名が【予約変更】かつ予約属性が新規の場合
            console.log(threads[i].getFirstMessageSubject());                                       // 件名ログ出力
            const arrReserve = arrGmailText1(gmailText, reserve, matchNumber, storeList);         // メールからデータを取得しIDの順番に配列化

            console.log(arrReserve)

            const newLastRow = analysisSheet.getRange(analysisSheetLastRow, 2).getNextDataCell(SpreadsheetApp.Direction.UP).getRow() + 1;

            // シート上に予約番号があるか配列で確認した後処理
            const reserveNumbers = analysisSheet.getRange(6, reserveNumCol + 1, newLastRow - 6, 1).getValues().reverse().flat(); // 新着順に予約番号を格納した配列

            loop: for(let n in reserveNumbers){                                                               // n = 0, 1, 2 〜
              console.log(reserve[reserveNumCol])
              if(reserveNumbers[n] == reserve[reserveNumCol]){                                                // 予約番号と同じ番号が過去の予約にあったら
                for(let a = newLastRow; a >= 6; a--){                                                         // aは行番号
                  if(analysisSheet.getRange(a, reserveNumCol + 1).getValue() == arrReserve[reserveNumCol]){   // 予約番号が一致していたら
                    // 日時だけ書き換えないから別変数に入れて、arrReserveを書き換える
                    const rd = analysisSheet.getRange(a, reserveProceduralDay + 1).getValue()
                    arrReserve[reserveProceduralDay] = rd

                    analysisSheet.getRange(a, 1, 1, 12).setValues([arrReserve]);
                    break loop;
                  }
                }
              }
              else if(n == reserveNumbers.length - 1){
                console.log("変更されたご予約の予約番号がありませんでした。");
                // 最終行に変更予約挿入
                analysisSheet.getRange(newLastRow, 1, 1, 12).setValues([arrReserve]);

                // 電話対応履歴に追加
                setTel(reserve[reserveNumCol])
              }          
            }
          }

          // ////////////////////////////
          // 1-3. 予約キャンセルの場合
          // ////////////////////////////
          else if(threads[i].getFirstMessageSubject().match(titleCancel)
          && plainBody.match(textNew)){                                                       // 件名が【予約キャンセル】かつ予約属性が新規の場合
            console.log(threads[i].getFirstMessageSubject());                                       // 件名ログ出力
            const arrReserve = arrGmailText1(gmailText, reserve, matchNumber, storeList);         // メールからデータを取得しIDの順番に配列化

            console.log(arrReserve)

            const newLastRow = analysisSheet.getRange(analysisSheetLastRow, 2).getNextDataCell(SpreadsheetApp.Direction.UP).getRow() + 1;

            // シート上に予約番号があるか配列で確認した後処理
            const reserveNumbers = analysisSheet.getRange(6, reserveNumCol + 1, newLastRow - 6, 1).getValues().reverse().flat();

            loop: for(let n in reserveNumbers){
              if(reserveNumbers[n] == reserve[reserveNumCol]){
                for(let a = newLastRow; a >= 6; a--){
                  if(analysisSheet.getRange(a, reserveNumCol + 1).getValue() == reserve[reserveNumCol]){
                    // 日時だけ書き換えないから別変数に入れて、arrReserveを書き換える
                    const rd = analysisSheet.getRange(a, reserveProceduralDay + 1).getValue()
                    arrReserve[reserveProceduralDay] = rd
                    arrReserve[visitStatus] = "×(予約キャンセル)"
                    arrReserve[firstSt]     = "9999_自動システム"

                    analysisSheet.getRange(a, 1, 1, 12).setValues([arrReserve]);
                    break loop;
                    }
                  }
                }
              else if(n == reserveNumbers.length - 1){
                console.log("キャンセルされたご予約の予約番号がありませんでした。");
                // 最終行にキャンセル予約挿入
                const arrReserve = arrGmailText1(gmailText, reserve, matchNumber, storeList);
                arrReserve[visitStatus] = "×(予約キャンセル)"
                arrReserve[firstSt]     = "9999_自動システム"
                analysisSheet.getRange(newLastRow, 1, 1, 12).setValues([arrReserve]);

                // 電話対応履歴に追加
                setTel(reserve[reserveNumCol])
              }
            }
          }
      }

      // 全パターン共通：新規ラベル付与 & 既読 & アーカイブ
      threads[i].addLabel(labelNew).markRead().moveToArchive();
    }

    // /////////////////////////////////////////////////////////////////
    // 2. 来店処理　既存ラベル付与
    // /////////////////////////////////////////////////////////////////
    else if(threads[i].getFirstMessageSubject().match(titleMember)
    || plainBody.match(textMember)){
      (threads[i].addLabel(labelExisting).markRead().moveToArchive() // 既存ラベル付与 & 既読 & アーカイブ
      && console.log(`既読 ${threads[i].getFirstMessageSubject()}`)); // 件名ログ出力
    }
  } // for文：ここまで
};


// メールの本文を整形し、必要項目をIDの順番に配列化
const arrGmailText1 = (gmailText, reserve, matchNumber, storeList) => {
  for(let x in gmailText){ // メールのテキストを1行ずつチェック
    gmailText[x].match("【予約番号】") ? reserve[reserveNumCol] = (gmailText[Number(x)].replace("【予約番号】","")).replace("\r", "") : "";
    gmailText[x].match("【予約日時】") ? reserve[firstReserveDay] = new Date(gmailText[Number(x)].replace("【予約日時】","").replace("～","")) : "";

    // 店舗名処理＆プッシュ
    if(gmailText[x].match("【予約店舗】")){
      const matchStore = gmailText[Number(x)].replace("【予約店舗】","").replace("\r", "");
      console.log(matchStore);
      for(let y in storeList){
        if(storeList[y].toString().match(matchStore)){
          reserve[firstShopId] = storeList[y];
          break;
        }
        else if(y == storeList.length - 1){
          "";
        }
      }
    }
    
    // 会員番号プッシュ
    gmailText[x].match(matchNumber) ? reserve[cusNum] = (gmailText[Number(x)].replace(matchNumber,"").replace("\r", "")) : ""; 

    if(gmailText[x].match("【お名前】")){
      reserve[cusName] = (gmailText[Number(x)].replace("【お名前】","")).replace("\r", "");

      // 漢字の名前がなければふりがなを入力する
      if(reserve[cusName] == ""){
        reserve[cusName] = (gmailText[Number(x) + 1].replace("【フリガナ】","").replace("\r", ""));
      }
    }

    gmailText[x].match("【電話番号】") ? reserve[cusTel] = (gmailText[Number(x)].replace("【電話番号】","")).replace("\r", "") : "";
    gmailText[x].match("【生年月日】") ? reserve[cusBirthDay] = (gmailText[Number(x)].replace("【生年月日】","").replace("\r", "")) : "";
  }

  return reserve;
};


// 指定した値が存在する列を取得する関数
const findCol = (val, dat) => {
  for(var i = 1; i < dat.length; i++){
    if(dat[i] === val){
      return i;
    }
  }
  return 0;
};
